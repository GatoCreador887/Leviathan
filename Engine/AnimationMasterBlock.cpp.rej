diff a/AnimationMasterBlock.cpp b/AnimationMasterBlock.cpp	(rejected hunks)
@@ -4,31 +4,35 @@
 #include "AnimationMasterBlock.h"
 #endif
 using namespace Leviathan;
+using namespace ozz::animation;
+using namespace ozz;
 // ------------------------------------ //
 DLLEXPORT Leviathan::AnimationMasterBlock::AnimationMasterBlock(){
 	AreAnimationsUpdated = false;
-	AnimationMSPassed = 0;
+	AnimationSecondsPassed = 0;
 	IsFrozen = false;
+	AnimationBoneCount = 0;
 
 	// start listening for frame end, to be able to flush the current state when frame ends //
 	this->RegisterForEvent(EVENT_TYPE_FRAME_END);
+
+	//memory::Allocator& allocator = ozz::memory::default_allocator();
+
+	// allocate buffers for sampling animations //
+	TempMatrices.resize((AnimationBoneCount + 3) / 4);
+	Cache.resize(AnimationBoneCount);
 }
 
 DLLEXPORT Leviathan::AnimationMasterBlock::~AnimationMasterBlock(){
 	// stop listening //
 	this->UnRegister(EVENT_TYPE_FRAME_END, true);
+
+	// release memory //
+	SAFE_DELETE_VECTOR(TempMatrices);
+	SAFE_DELETE_VECTOR(Cache);
 }
 // ------------------------------------ //
-DLLEXPORT void Leviathan::AnimationMasterBlock::HookBones(vector<shared_ptr<GameObject::SkeletonBone>> &bonestohook){
-	// make sure that there is enough space //
-	HookedBones.reserve(HookedBones.size()+bonestohook.size());
-
-	// copy shared ptrs over //
-	for(unsigned int i = 0; i < bonestohook.size(); i++){
-		HookedBones.push_back(bonestohook[i]);
-	}
 
-}
 // ------------------------------------ //
 
 // ------------------------------------ //
@@ -45,23 +49,23 @@
 	}
 
 	AreAnimationsUpdated = true;
-	AnimationMSPassed += mspassed;
+	AnimationSecondsPassed += mspassed/1000.f;
 
 	// update all animations based on current total time passed //
-	// and send bones to animations for their positions to be updated //
-	for(unsigned int i = 0; i < Animations.size(); i++){
-		
-	}
-	// update them by random amount //
-
 
-	for(unsigned int i = 0; i < HookedBones.size(); i++){
-		Float3 pos = HookedBones[i]->GetRestPosition();
-		// translate //
-		//pos.X(pos.X() + 0.001f*AnimationMSPassed);
-		pos.Y(pos.Y() + 0.001f*AnimationMSPassed);
-		// set position to bone //
-		HookedBones[i]->SetAnimationPosition(pos);
+	// sample animation at current time //
+	SamplingJob sampler;
+	// set sampler parameters //
+	sampler.animation = Animations[0]->RealAnimation.get();
+	sampler.cache = Cache[0];
+	sampler.time = AnimationSecondsPassed;
+	sampler.output_begin = TempMatrices.front();
+	sampler.output_end = TempMatrices.back();
+
+	// run sampling of animation //
+	if(!sampler.Run()){
+		DEBUG_BREAK;
+		return false;
 	}
 
 	return 2;
